<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8"/>
<meta name="viewport" content="width=device-width, initial-scale=1.0"/>
<title>The Luchabrarian — Playable Simulation</title>
<style>
  @import url('https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap');
  * { margin:0; padding:0; box-sizing:border-box; }
  body {
    background: #0a0a14;
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: center;
    height: 100vh;
    overflow: hidden;
    font-family: 'Press Start 2P', monospace;
    user-select: none;
  }
  #wrap {
    position: relative;
    border: 3px solid #2a2a4a;
    box-shadow: 0 0 60px rgba(180,40,40,0.12), inset 0 0 80px rgba(0,0,0,0.4);
  }
  canvas { display:block; image-rendering: pixelated; }
  #wrap::after {
    content:'';
    position:absolute; inset:0; pointer-events:none;
    background: repeating-linear-gradient(0deg, transparent, transparent 3px, rgba(0,0,0,0.07) 3px, rgba(0,0,0,0.07) 6px);
    z-index:10;
  }
  #title-bar {
    color:#c8a84a; font-size:9px; letter-spacing:2px;
    text-transform:uppercase; margin-bottom:6px; opacity:0.6;
  }
  #controls-hint {
    color:#4a4a6a; font-size:7px; margin-top:8px; letter-spacing:1px;
    text-align:center; line-height:1.8;
  }
</style>
</head>
<body>
<div id="title-bar">The Luchabrarian</div>
<div id="wrap"><canvas id="c"></canvas></div>
<div id="controls-hint">
  WASD / ARROWS — Move &nbsp;|&nbsp; SPACE — Dash &nbsp;|&nbsp; Walk over books to pick up &nbsp;|&nbsp; Walk into matching shelf (or trash can) to file
</div>
<script>
// ═══════════════════════════════════════════════════════════════════════════
// THE LUCHABRARIAN — Full playable simulation (single-file, canvas 2D)
// ═══════════════════════════════════════════════════════════════════════════

const canvas = document.getElementById('c');
const ctx = canvas.getContext('2d');

// ── Config ────────────────────────────────────────────────────────────────
const W = 640, H = 480, TILE = 32;
canvas.width = W; canvas.height = H;
document.getElementById('wrap').style.width  = W + 'px';
document.getElementById('wrap').style.height = H + 'px';

const BOOK_TYPES = ['ROMANCE','SCIENCE','HORROR','SCIFI','TABLETS','FORBIDDEN','MANGA','TRASH','MYSTERY'];
const BOOK_LABELS = {
  ROMANCE:'Romance', SCIENCE:'Science', HORROR:'Horror', SCIFI:'Sci-Fi',
  TABLETS:'Tablets', FORBIDDEN:'Forbidden', MANGA:'Manga', TRASH:'Trash', MYSTERY:'Mystery'
};
const BOOK_COLORS = {
  ROMANCE:'#e84a8a', SCIENCE:'#2ea05c', HORROR:'#7a2ec0', SCIFI:'#2e5cc0',
  TABLETS:'#00bfff', FORBIDDEN:'#222222', MANGA:'#d4a82e', TRASH:'#e87a2e', MYSTERY:'#8a8a9a'
};
const SHELF_GLOW = {
  ROMANCE:'#ff6aaa', SCIENCE:'#2aaa5c', HORROR:'#aa4aff', SCIFI:'#4a8cff',
  TABLETS:'#40ddff', FORBIDDEN:'#666666', MANGA:'#f0c840', TRASH:'#ff8840', MYSTERY:'#aaaacc'
};

// Shelves hold every type EXCEPT Trash. Trash has its own can.
const SHELF_DEFS = [
  { x:2,  y:2,  type:'ROMANCE' },
  { x:8,  y:2,  type:'SCIENCE' },
  { x:14, y:2,  type:'HORROR' },
  { x:2,  y:6,  type:'SCIFI' },
  { x:14, y:6,  type:'TABLETS' },
  { x:2,  y:11, type:'FORBIDDEN' },
  { x:8,  y:11, type:'MANGA' },
  { x:14, y:11, type:'MYSTERY' },
];
// Trash can position (tile coords)
const TRASH_DEF = { x:8, y:6 };

const PLAYER_SPEED = 160, DASH_SPEED = 340, DASH_DUR = 220, DASH_CD = 600;
const CARRY_LIMIT = 3, SLOW = 0.6;
const GAME_TIME = 90;
const GHOST_FIRST = 8000, GHOST_INTERVAL = 12000, GHOST_SPEED = 55;
const ESCALATION_MS = 20000;
const COMBO_TIMEOUT = 3500, SCORE_BASE = 100, COMBO_MULT = 1.5;

// ── Input ─────────────────────────────────────────────────────────────────
const keys = {};
const keyDown = {}, keyUp = {};
window.addEventListener('keydown', e => { keys[e.key.toLowerCase()] = true; keyDown[e.key.toLowerCase()] = true; e.preventDefault(); });
window.addEventListener('keyup',   e => { keys[e.key.toLowerCase()] = false; keyUp[e.key.toLowerCase()] = true; });

// ── Math helpers ──────────────────────────────────────────────────────────
function dist(ax,ay,bx,by){ const dx=ax-bx, dy=ay-by; return Math.sqrt(dx*dx+dy*dy); }
function norm(x,y){ const l=Math.sqrt(x*x+y*y); return l?[x/l,y/l]:[0,0]; }
function lerp(a,b,t){ return a+(b-a)*t; }
function rnd(min,max){ return min+Math.random()*(max-min); }
function rint(min,max){ return Math.floor(rnd(min,max+1)); }

// ═══════════════════════════════════════════════════════════════════════════
// STATE
// ═══════════════════════════════════════════════════════════════════════════
let state = 'title'; // title | play | paused | gameover
let score, timeLeft, combo, comboTimer, escalationTimer, ghostTimer, escalLevel;
let player, books, shelves, trashCan, ghosts, particles, flashAlpha, feedbacks;
let escWas = false;

function initGame() {
  state = 'play';
  score = 0; timeLeft = GAME_TIME; combo = 0; comboTimer = 0;
  escalationTimer = ESCALATION_MS; ghostTimer = GHOST_FIRST; escalLevel = 0;
  flashAlpha = 0; feedbacks = [];

  // Player
  player = {
    x: W/2, y: H/2,
    dir: 0, // 0=down 1=right 2=up 3=left
    carrying: [],
    dashing: false, dashCd: 0,
    bobPhase: 0,
    vx:0, vy:0,
    health: 100
  };

  // Shelves
  shelves = SHELF_DEFS.map(d => ({
    x: d.x * TILE + TILE/2,
    y: d.y * TILE + TILE/2,
    type: d.type,
    glowPulse: 0,
    slots: [
      { x: d.x*TILE+TILE/2 - 24, y: d.y*TILE+TILE/2+8, filled:false },
      { x: d.x*TILE+TILE/2,      y: d.y*TILE+TILE/2+8, filled:false },
      { x: d.x*TILE+TILE/2 + 24, y: d.y*TILE+TILE/2+8, filled:false },
    ]
  }));

  // Trash can
  trashCan = {
    x: TRASH_DEF.x * TILE + TILE/2,
    y: TRASH_DEF.y * TILE + TILE/2,
    glowPulse: 0
  };

  // Books
  books = [];
  for (let i = 0; i < 5; i++) spawnBook();

  ghosts = [];
  particles = [];
}

// ── Spawn book at random safe floor position ─────────────────────────────
function spawnBook() {
  const type = BOOK_TYPES[rint(0, BOOK_TYPES.length-1)];
  let bx, by;
  for (let t = 0; t < 60; t++) {
    bx = rnd(48, W-48); by = rnd(48, H-48);
    let ok = true;
    for (const s of shelves) if (dist(bx,by,s.x,s.y)<72) { ok=false; break; }
    if (ok && dist(bx,by,trashCan.x,trashCan.y)<60) ok=false;
    if (ok && dist(bx,by,player.x,player.y)>50) break;
  }
  books.push({ x:bx, y:by, type, state:'floor', rot: rnd(-0.4,0.4), bobPhase: Math.random()*Math.PI*2, pickupCd:0 });
}

// ── Spawn ghost at map edge ──────────────────────────────────────────────
function spawnGhost() {
  const edge = rint(0,3);
  let gx, gy;
  if (edge===0) { gx=rnd(20,W-20); gy=16; }
  else if (edge===1) { gx=rnd(20,W-20); gy=H-16; }
  else if (edge===2) { gx=16; gy=rnd(20,H-20); }
  else { gx=W-16; gy=rnd(20,H-20); }
  ghosts.push({ x:gx, y:gy, phase:Math.random()*Math.PI*2, alive:true });
}

// ── Particles ─────────────────────────────────────────────────────────────
function burst(x,y,count,color,life) {
  for (let i=0;i<count;i++) particles.push({
    x,y, vx:rnd(-80,80), vy:rnd(-80,80), life, maxLife:life, color, size:rnd(1.5,3.5)
  });
}

// ── Feedback label ────────────────────────────────────────────────────────
function addFeedback(x,y,txt,color) {
  feedbacks.push({ x, y, txt, color, life:1200, maxLife:1200 });
}

// ═══════════════════════════════════════════════════════════════════════════
// UPDATE
// ═══════════════════════════════════════════════════════════════════════════
let lastTime = 0;
function update(dt) {
  // ── clear per-frame input edges ─────────────────────────────────────
  for (const k in keyDown) keyDown[k]=false;
  for (const k in keyUp)   keyUp[k]=false;

  if (state==='title') { updateTitle(dt); escWas = keys['escape']; return; }
  if (state==='gameover') { updateGameOver(dt); escWas = keys['escape']; return; }
  if (state==='paused') { updatePaused(dt); escWas = keys['escape']; return; }

  // ── ESC → pause (edge-detected) ─────────────────────────────────────
  if (keys['escape'] && !escWas) { state = 'paused'; escWas = keys['escape']; return; }
  escWas = keys['escape'];

  // ── Timer ───────────────────────────────────────────────────────────
  timeLeft -= dt/1000;
  if (timeLeft<=0) { timeLeft=0; endGame(false); return; }

  // ── Player movement ─────────────────────────────────────────────────
  updatePlayer(dt);

  // ── Books ───────────────────────────────────────────────────────────
  updateBooks(dt);

  // ── Shelves ─────────────────────────────────────────────────────────
  updateShelves(dt);

  // ── Ghosts ──────────────────────────────────────────────────────────
  ghostTimer -= dt;
  if (ghostTimer<=0) {
    spawnGhost();
    ghostTimer = Math.max(4000, GHOST_INTERVAL - escalLevel*2000);
  }
  updateGhosts(dt);

  // ── Escalation ──────────────────────────────────────────────────────
  escalationTimer -= dt;
  if (escalationTimer<=0) {
    escalationTimer = ESCALATION_MS;
    escalLevel++;
    for (let i=0;i<3;i++) spawnBook();
    addFeedback(W/2, H/2-40, 'WAVE '+escalLevel+'!', '#d62a2a');
  }

  // ── Combo timeout ───────────────────────────────────────────────────
  if (combo>0) {
    comboTimer -= dt;
    if (comboTimer<=0) combo=0;
  }

  // ── Particles ───────────────────────────────────────────────────────
  updateParticles(dt);

  // ── Feedbacks ───────────────────────────────────────────────────────
  for (let i=feedbacks.length-1;i>=0;i--) {
    feedbacks[i].life -= dt;
    feedbacks[i].y -= dt*0.02;
    if (feedbacks[i].life<=0) feedbacks.splice(i,1);
  }

  // ── Flash decay ─────────────────────────────────────────────────────
  if (flashAlpha>0) flashAlpha -= dt*0.003;

  // ── Win check: all books filed ──────────────────────────────────────
  if (books.every(b => b.state==='filed')) { endGame(true); return; }
}

function updateTitle(dt) {
  if (keys[' '] && !updateTitle._was) { initGame(); }
  updateTitle._was = keys[' '];
}
function updateGameOver(dt) {
  if ((keys[' '] && !updateGameOver._was) || keys['enter']) { initGame(); }
  updateGameOver._was = keys[' '];
  if (keys['escape'] && !escWas) state='title';
}

function updatePaused(dt) {
  // ESC toggles back to play
  if (keys['escape'] && !escWas) { state = 'play'; return; }
  // Enter or Space → quit to title
  if ((keys[' '] && !updatePaused._wasSpace) || (keys['enter'] && !updatePaused._wasEnter)) {
    state = 'title';
  }
  updatePaused._wasSpace = keys[' '];
  updatePaused._wasEnter = keys['enter'];
}

// ── Player ──────────────────────────────────────────────────────────────
function updatePlayer(dt) {
  const p = player;
  p.bobPhase += dt*0.006;

  // Dash cooldown
  if (p.dashCd>0) p.dashCd -= dt;

  // Dash trigger (space — edge-detected via dashWas)
  if (keys[' '] && !p.dashWas && p.dashCd<=0 && !p.dashing) {
    p.dashing = true;
    p.dashCd = DASH_CD;
    let [dx,dy] = getDirVec();
    if (dx===0&&dy===0) {
      // dash in facing direction
      if (p.dir===0) dy=1; else if (p.dir===1) dx=1;
      else if (p.dir===2) dy=-1; else dx=-1;
    }
    [dx,dy] = norm(dx,dy);
    p.vx = dx*DASH_SPEED; p.vy = dy*DASH_SPEED;
    burst(p.x, p.y, 10, '#ffffff', 220);
    setTimeout(()=>{ p.dashing=false; }, DASH_DUR);
  }

  if (!p.dashing) {
    let [dx,dy] = getDirVec();
    // Facing
    if (dx!==0||dy!==0) {
      if (Math.abs(dx)>=Math.abs(dy)) p.dir = dx>0?1:3;
      else p.dir = dy>0?0:2;
    }
    [dx,dy] = norm(dx,dy);
    const spd = p.carrying.length>=CARRY_LIMIT ? PLAYER_SPEED*SLOW : PLAYER_SPEED;
    p.vx = dx*spd; p.vy = dy*spd;
  }

  // Move
  p.x += p.vx * dt/1000;
  p.y += p.vy * dt/1000;
  // Clamp
  p.x = Math.max(20, Math.min(W-20, p.x));
  p.y = Math.max(20, Math.min(H-20, p.y));

  // Shelf collision (push out)
  for (const s of shelves) {
    const sw=40, sh=28;
    const ox = p.x - s.x, oy = p.y - s.y;
    const hw = sw/2+12, hh = sh/2+12;
    if (Math.abs(ox)<hw && Math.abs(oy)<hh) {
      const px = (ox>0?1:-1)*(hw-Math.abs(ox));
      const py = (oy>0?1:-1)*(hh-Math.abs(oy));
      if (Math.abs(px)<Math.abs(py)) p.x += px; else p.y += py;
    }
  }
  // Trash can collision (push out)
  {
    const sw=36, sh=36;
    const ox = p.x - trashCan.x, oy = p.y - trashCan.y;
    const hw = sw/2+10, hh = sh/2+10;
    if (Math.abs(ox)<hw && Math.abs(oy)<hh) {
      const px = (ox>0?1:-1)*(hw-Math.abs(ox));
      const py = (oy>0?1:-1)*(hh-Math.abs(oy));
      if (Math.abs(px)<Math.abs(py)) p.x += px; else p.y += py;
    }
  }

  // Edge tracker for space dash
  p.dashWas = keys[' '];
}

function getDirVec() {
  let dx=0,dy=0;
  if (keys['a']||keys['arrowleft'])  dx-=1;
  if (keys['d']||keys['arrowright']) dx+=1;
  if (keys['w']||keys['arrowup'])    dy-=1;
  if (keys['s']||keys['arrowdown'])  dy+=1;
  return [dx,dy];
}

// ── Books ─────────────────────────────────────────────────────────────────
function updateBooks(dt) {
  for (const b of books) {
    if (b.state==='floor') {
      b.bobPhase += dt*0.003;
      if (b.pickupCd>0) b.pickupCd -= dt;
    }
  }

  // Auto-pickup: walk over floor books
  if (player.carrying.length < CARRY_LIMIT) {
    for (const b of books) {
      if (b.state!=='floor' || b.pickupCd>0) continue;
      if (dist(player.x, player.y, b.x, b.y) < 34) {
        b.state = 'carried';
        player.carrying.push(b);
        burst(b.x, b.y, 6, '#40ff80', 350);
        break;
      }
    }
  }

  // Auto-file: walk into shelf with matching book
  for (const s of shelves) {
    if (dist(player.x, player.y, s.x, s.y) > 52) continue;
    const idx = player.carrying.findIndex(b => b.type===s.type);
    if (idx===-1) continue;
    const b = player.carrying[idx];
    player.carrying.splice(idx,1);
    fileBook(b, s);
    break;
  }

  // Auto-file: walk into trash can with a TRASH book
  if (dist(player.x, player.y, trashCan.x, trashCan.y) < 48) {
    const idx = player.carrying.findIndex(b => b.type==='TRASH');
    if (idx !== -1) {
      const b = player.carrying[idx];
      player.carrying.splice(idx,1);
      trashBook(b);
    }
  }
}

function fileBook(book, shelf) {
  book.state = 'filed';
  // Place on shelf slot
  const slot = shelf.slots.find(sl=>!sl.filled);
  if (slot) { book.x=slot.x; book.y=slot.y; slot.filled=true; }
  else { book.x=shelf.x; book.y=shelf.y-32; }
  book.rot=0;

  // Score
  combo++;
  comboTimer = COMBO_TIMEOUT;
  const mult = combo<=1 ? 1 : 1+(combo-1)*(COMBO_MULT-1);
  const pts = Math.round(SCORE_BASE * mult);
  score += pts;

  // Effects
  burst(shelf.x, shelf.y, 12, SHELF_GLOW[shelf.type], 500);
  const label = combo>=2 ? `+${pts} (${combo}x)` : `+${pts}`;
  const col = combo>=3?'#ff4040':combo>=2?'#ff8840':'#40ff80';
  addFeedback(shelf.x, shelf.y-40, label, col);
  shelf.glowPulse = 1;
}

function trashBook(book) {
  book.state = 'filed'; // removed from play
  // Animate it into the can: just place it at can center (it vanishes visually)
  book.x = trashCan.x;
  book.y = trashCan.y;
  book.rot = 0;

  // Score (same combo logic)
  combo++;
  comboTimer = COMBO_TIMEOUT;
  const mult = combo<=1 ? 1 : 1+(combo-1)*(COMBO_MULT-1);
  const pts = Math.round(SCORE_BASE * mult);
  score += pts;

  // Effects — orange burst into the can
  burst(trashCan.x, trashCan.y, 14, '#ff8840', 450);
  const label = combo>=2 ? `+${pts} (${combo}x)` : `+${pts}`;
  const col = combo>=3?'#ff4040':combo>=2?'#ff8840':'#40ff80';
  addFeedback(trashCan.x, trashCan.y-36, label, col);
  trashCan.glowPulse = 1;
}

function updateShelves(dt) {
  for (const s of shelves) {
    if (s.glowPulse>0) s.glowPulse -= dt*0.003;
  }
  if (trashCan.glowPulse>0) trashCan.glowPulse -= dt*0.003;
}

// ── Ghosts ────────────────────────────────────────────────────────────────
function updateGhosts(dt) {
  for (let i=ghosts.length-1;i>=0;i--) {
    const g = ghosts[i];
    if (!g.alive) { ghosts.splice(i,1); continue; }

    // Chase
    const [dx,dy] = norm(player.x-g.x, player.y-g.y);
    g.x += dx*GHOST_SPEED*dt/1000;
    g.y += dy*GHOST_SPEED*dt/1000;
    g.phase += dt*0.004;

    // Collision with player
    if (dist(g.x, g.y, player.x, player.y) < 28) {
      // Damage
      player.health -= 20;
      if (player.health < 0) player.health = 0;
      flashAlpha = 0.22;
      combo = 0;

      // Drop all books
      if (player.carrying.length>0) {
        const dropped = [...player.carrying];
        player.carrying = [];
        dropped.forEach((b,i) => {
          const angle = (i/dropped.length)*Math.PI*2;
          b.x = player.x + Math.cos(angle)*35;
          b.y = player.y + Math.sin(angle)*35;
          b.state = 'floor';
          b.rot = rnd(-0.4,0.4);
          b.pickupCd = 1500;
        });
      }

      burst(g.x, g.y, 18, '#aa44ff', 600);
      g.alive = false;
      ghosts.splice(i,1);

      // Health depleted — game over
      if (player.health <= 0) { endGame(false); return; }
    }
  }
}

function updateParticles(dt) {
  for (let i=particles.length-1;i>=0;i--) {
    const p = particles[i];
    p.x += p.vx*dt/1000;
    p.y += p.vy*dt/1000;
    p.life -= dt;
    if (p.life<=0) particles.splice(i,1);
  }
}

function endGame(won) {
  state='gameover';
  player.vx=0; player.vy=0;
  player._won = won;
  player._score = score;
  player._booksLeft = books.filter(b=>b.state!=='filed').length;
  player._cause = won ? 'win' : (player.health <= 0 ? 'health' : 'time');
}

// ═══════════════════════════════════════════════════════════════════════════
// RENDER
// ═══════════════════════════════════════════════════════════════════════════
function render() {
  ctx.clearRect(0,0,W,H);

  if (state==='title') { renderTitle(); return; }
  if (state==='gameover') { renderGameOver(); return; }

  renderFloor();
  renderShelves();
  renderTrashCan();
  renderBooks();
  renderPlayer();
  renderGhosts();
  renderParticles();
  renderHUD();
  renderFeedbacks();
  renderFlash();

  // Pause overlay drawn on top of the live frame
  if (state === 'paused') renderPauseOverlay();
}

// ── Floor ─────────────────────────────────────────────────────────────────
const floorColors = ['#e8dfcf','#d4c8b0','#c8b898'];
function renderFloor() {
  for (let row=0; row<H/TILE; row++) {
    for (let col=0; col<W/TILE; col++) {
      const v = ((col*7+row*13)%3);
      ctx.fillStyle = floorColors[v];
      ctx.fillRect(col*TILE, row*TILE, TILE, TILE);
      // subtle grid line
      ctx.fillStyle = 'rgba(0,0,0,0.04)';
      ctx.fillRect(col*TILE, row*TILE, TILE, 1);
      ctx.fillRect(col*TILE, row*TILE, 1, TILE);
    }
  }
}

// ── Shelves ───────────────────────────────────────────────────────────────
function renderShelves() {
  for (const s of shelves) {
    const hasMatch = player.carrying.some(b=>b.type===s.type);
    const d = dist(player.x,player.y,s.x,s.y);
    const glowing = hasMatch && d<55;

    // Glow ring
    if (glowing || s.glowPulse>0) {
      const alpha = glowing ? 0.25 : s.glowPulse*0.3;
      ctx.save();
      ctx.globalAlpha = alpha;
      ctx.fillStyle = SHELF_GLOW[s.type];
      ctx.beginPath();
      ctx.arc(s.x, s.y, 44+Math.sin(Date.now()*0.006)*4, 0, Math.PI*2);
      ctx.fill();
      ctx.globalAlpha = alpha*0.5;
      ctx.beginPath();
      ctx.arc(s.x, s.y, 56, 0, Math.PI*2);
      ctx.fill();
      ctx.restore();
    }

    // Shelf body
    const sw=80, sh=56;
    const sx=s.x-sw/2, sy=s.y-sh/2;
    // Shadow
    ctx.fillStyle='rgba(0,0,0,0.18)';
    ctx.fillRect(sx+3, sy+3, sw, sh);
    // Main wood
    ctx.fillStyle='#c48e5a';
    ctx.fillRect(sx, sy, sw, sh);
    // Dark inner
    ctx.fillStyle='#8b5e3a';
    ctx.fillRect(sx+4, sy+4, sw-8, sh-8);
    // Shelf planks (3 horizontal)
    ctx.fillStyle='#c48e5a';
    ctx.fillRect(sx+4, sy+14, sw-8, 4);
    ctx.fillRect(sx+4, sy+28, sw-8, 4);
    ctx.fillRect(sx+4, sy+42, sw-8, 4);
    // Plank shadows
    ctx.fillStyle='#6b442a';
    ctx.fillRect(sx+4, sy+18, sw-8, 1);
    ctx.fillRect(sx+4, sy+32, sw-8, 1);
    // Vertical dividers
    ctx.fillStyle='#6b442a';
    ctx.fillRect(sx+26, sy+4, 2, sh-8);
    ctx.fillRect(sx+52, sy+4, 2, sh-8);
    // Outline
    ctx.strokeStyle='#1a1a1a';
    ctx.lineWidth=2;
    ctx.strokeRect(sx+0.5, sy+0.5, sw-1, sh-1);

    // Label
    const label = BOOK_LABELS[s.type];
    ctx.save();
    ctx.fillStyle='rgba(0,0,0,0.75)';
    roundRect(ctx, s.x-30, sy-22, 60, 18, 4);
    ctx.fill();
    ctx.strokeStyle = SHELF_GLOW[s.type];
    ctx.lineWidth=2;
    roundRect(ctx, s.x-30, sy-22, 60, 18, 4);
    ctx.stroke();
    ctx.restore();

    ctx.fillStyle = SHELF_GLOW[s.type];
    ctx.font = 'bold 8px "Press Start 2P", monospace';
    ctx.textAlign='center';
    ctx.textBaseline='middle';
    ctx.fillText(label.toUpperCase(), s.x, sy-13);
  }
}

// ── Trash Can ─────────────────────────────────────────────────────────────
function renderTrashCan() {
  const tc = trashCan;
  const hasTrash = player.carrying.some(b => b.type==='TRASH');
  const d = dist(player.x, player.y, tc.x, tc.y);
  const glowing = hasTrash && d < 48;

  // Glow
  if (glowing || tc.glowPulse > 0) {
    const alpha = glowing ? 0.3 : tc.glowPulse * 0.35;
    ctx.save();
    ctx.globalAlpha = alpha;
    ctx.fillStyle = '#ff8840';
    ctx.beginPath();
    ctx.arc(tc.x, tc.y, 30 + Math.sin(Date.now()*0.006)*3, 0, Math.PI*2);
    ctx.fill();
    ctx.globalAlpha = alpha * 0.45;
    ctx.beginPath();
    ctx.arc(tc.x, tc.y, 42, 0, Math.PI*2);
    ctx.fill();
    ctx.restore();
  }

  // Shadow
  ctx.fillStyle = 'rgba(0,0,0,0.22)';
  ctx.fillRect(tc.x - 16, tc.y + 14, 32, 6);

  // Can body (tapered bucket shape)
  ctx.fillStyle = '#5a5a6a';
  ctx.beginPath();
  ctx.moveTo(tc.x - 14, tc.y - 10);
  ctx.lineTo(tc.x + 14, tc.y - 10);
  ctx.lineTo(tc.x + 11, tc.y + 14);
  ctx.lineTo(tc.x - 11, tc.y + 14);
  ctx.closePath();
  ctx.fill();

  // Inner dark (the opening)
  ctx.fillStyle = '#2a2a2a';
  ctx.beginPath();
  ctx.moveTo(tc.x - 12, tc.y - 8);
  ctx.lineTo(tc.x + 12, tc.y - 8);
  ctx.lineTo(tc.x + 10, tc.y - 4);
  ctx.lineTo(tc.x - 10, tc.y - 4);
  ctx.closePath();
  ctx.fill();

  // Rim (lighter top edge)
  ctx.fillStyle = '#7a7a8a';
  ctx.fillRect(tc.x - 15, tc.y - 12, 30, 4);

  // Rim highlight
  ctx.fillStyle = '#9a9aaa';
  ctx.fillRect(tc.x - 14, tc.y - 11, 28, 1);

  // Lid handle (small arc on top)
  ctx.strokeStyle = '#7a7a8a';
  ctx.lineWidth = 2.5;
  ctx.beginPath();
  ctx.arc(tc.x, tc.y - 14, 6, Math.PI, 0);
  ctx.stroke();

  // Outline
  ctx.strokeStyle = '#1a1a1a';
  ctx.lineWidth = 1.5;
  ctx.beginPath();
  ctx.moveTo(tc.x - 14, tc.y - 10);
  ctx.lineTo(tc.x + 14, tc.y - 10);
  ctx.lineTo(tc.x + 11, tc.y + 14);
  ctx.lineTo(tc.x - 11, tc.y + 14);
  ctx.closePath();
  ctx.stroke();

  // Label
  ctx.fillStyle = 'rgba(0,0,0,0.75)';
  roundRect(ctx, tc.x - 22, tc.y - 32, 44, 16, 4);
  ctx.fill();
  ctx.strokeStyle = '#ff8840';
  ctx.lineWidth = 2;
  roundRect(ctx, tc.x - 22, tc.y - 32, 44, 16, 4);
  ctx.stroke();

  ctx.fillStyle = '#ff8840';
  ctx.font = 'bold 8px "Press Start 2P", monospace';
  ctx.textAlign = 'center';
  ctx.textBaseline = 'middle';
  ctx.fillText('TRASH', tc.x, tc.y - 24);
}

// ── Books ─────────────────────────────────────────────────────────────────
function renderBooks() {
  for (const b of books) {
    if (b.state==='carried') continue; // drawn on player
    if (b.state==='filed' && b.type==='TRASH') continue; // vanished into trash can
    const bw=14, bh=20;
    const bob = b.state==='floor' ? Math.sin(Date.now()*0.003+b.bobPhase)*2 : 0;
    const bx = b.x - bw/2, by = b.y - bh/2 + bob;
    const scale = b.state==='filed' ? 0.75 : 1;

    ctx.save();
    ctx.translate(b.x, b.y + bob);
    ctx.rotate(b.rot);
    ctx.scale(scale, scale);

    // Shadow
    if (b.state==='floor') {
      ctx.fillStyle='rgba(0,0,0,0.2)';
      ctx.fillRect(-bw/2+1, -bh/2+bh-2, bw, 3);
    }

    // Cover
    ctx.fillStyle = BOOK_COLORS[b.type];
    ctx.fillRect(-bw/2, -bh/2, bw, bh);
    // Spine
    ctx.fillStyle='#1a1a1a';
    ctx.fillRect(-bw/2-1, -bh/2, 2, bh);
    // Pages
    ctx.fillStyle='#f0ebd6';
    ctx.fillRect(bw/2-1, -bh/2, 2, bh);
    // Title stripe
    ctx.fillStyle='rgba(0,0,0,0.35)';
    ctx.fillRect(-bw/2+2, -bh/2+5, bw-4, 2);
    ctx.fillRect(-bw/2+2, -bh/2+9, bw-4, 2);
    // Center dot
    ctx.fillStyle='rgba(255,255,255,0.7)';
    ctx.fillRect(-2, -bh/2+6, 3, 3);
    // Outline
    ctx.strokeStyle='#1a1a1a';
    ctx.lineWidth=1.5;
    ctx.strokeRect(-bw/2+0.5, -bh/2+0.5, bw-1, bh-1);

    ctx.restore();

    // Label (floor only)
    if (b.state==='floor') {
      const label = BOOK_LABELS[b.type];
      const tw = ctx.measureText(label).width;
      ctx.fillStyle='rgba(0,0,0,0.7)';
      ctx.fillRect(b.x-tw/2-4, b.y-bh/2-14+bob, tw+8, 12);
      ctx.fillStyle='#e8e8e8';
      ctx.font = '7px "Press Start 2P", monospace';
      ctx.textAlign='center';
      ctx.textBaseline='middle';
      ctx.fillText(label, b.x, b.y-bh/2-8+bob);
    }
  }
}

// ── Player (Luchador) ─────────────────────────────────────────────────────
function renderPlayer() {
  const p = player;
  const bob = Math.sin(p.bobPhase)*1.5;
  const px = p.x, py = p.y + bob;

  // Shadow
  ctx.fillStyle='rgba(0,0,0,0.22)';
  ctx.beginPath();
  ctx.ellipse(px, py+16, 14, 5, 0, 0, Math.PI*2);
  ctx.fill();

  ctx.save();
  ctx.translate(px, py);

  const facing = p.dir; // 0=down 1=right 2=up 3=left
  const isSide = (facing===1||facing===3);
  const flip = facing===3;
  if (flip) ctx.scale(-1,1);

  // Legs
  ctx.fillStyle='#2c2c6e';
  if (!isSide) {
    ctx.fillRect(-5, 8, 4, 8); // left
    ctx.fillRect(1,  8, 4, 8); // right
  } else {
    ctx.fillRect(-2, 8, 5, 8);
    ctx.fillRect(-1, 9, 5, 8);
  }
  // Boots
  ctx.fillStyle='#3d2b1a';
  if (!isSide) {
    ctx.fillRect(-5, 16, 4, 3);
    ctx.fillRect(1,  16, 4, 3);
  } else {
    ctx.fillRect(-2, 16, 5, 3);
    ctx.fillRect(-1, 17, 5, 3);
  }

  // Body / Vest
  ctx.fillStyle='#b81c1c';
  ctx.fillRect(-7, -2, 14, 10);
  // Chest stripe
  ctx.fillStyle='#1e7a1e';
  ctx.fillRect(-5, 0, 10, 5);

  // Arms
  ctx.fillStyle='#e8b88a';
  if (!isSide) {
    ctx.fillRect(-10, -1, 3, 7);
    ctx.fillRect(7,   -1, 3, 7);
  } else {
    ctx.fillRect(7, -1, 3, 7);
  }
  // Arm sleeves
  ctx.fillStyle='#b81c1c';
  if (!isSide) {
    ctx.fillRect(-10, -1, 3, 3);
    ctx.fillRect(7,   -1, 3, 3);
  } else {
    ctx.fillRect(7, -1, 3, 3);
  }

  // Head
  ctx.fillStyle='#e8b88a';
  ctx.fillRect(-6, -12, 12, 8);

  // Mask
  ctx.fillStyle='#d62a2a';
  ctx.fillRect(-6, -12, 12, 6);
  // Forehead white stripe
  ctx.fillStyle='#ffffff';
  ctx.fillRect(-6, -12, 12, 2);
  // Green accent
  ctx.fillStyle='#2a8c2a';
  ctx.fillRect(-6, -10, 12, 1);
  // Eyes
  if (facing!==2) {
    ctx.fillStyle='#1a1a1a';
    if (!isSide||facing===1) {
      ctx.fillRect(1, -8, 3, 2);
    }
    if (!isSide) {
      ctx.fillRect(-4, -8, 3, 2);
    }
  }

  // Outline (head)
  ctx.strokeStyle='#1a1a1a';
  ctx.lineWidth=1.5;
  ctx.strokeRect(-6.5, -12.5, 13, 9);
  // Outline (body)
  ctx.strokeRect(-7.5, -2.5, 15, 11);

  ctx.restore();

  // Carried books stack (above head)
  p.carrying.forEach((b, i) => {
    const bx = px + (i-1)*11;
    const by = py - 22 - i*6;
    const bw=10, bh=14;
    ctx.save();
    ctx.translate(bx, by);
    ctx.fillStyle = BOOK_COLORS[b.type];
    ctx.fillRect(-bw/2, -bh/2, bw, bh);
    ctx.strokeStyle='#1a1a1a';
    ctx.lineWidth=1;
    ctx.strokeRect(-bw/2+0.5, -bh/2+0.5, bw-1, bh-1);
    ctx.restore();
  });

  // Dash trail
  if (p.dashing) {
    burst(px, py, 3, '#ffffff', 180);
  }
}

// ── Ghosts ────────────────────────────────────────────────────────────────
function renderGhosts() {
  for (const g of ghosts) {
    if (!g.alive) continue;
    const bob = Math.sin(g.phase)*4;
    const gx = g.x, gy = g.y + bob;

    // Glow
    ctx.save();
    ctx.globalAlpha=0.15;
    ctx.fillStyle='#8888ff';
    ctx.beginPath();
    ctx.arc(gx, gy, 22, 0, Math.PI*2);
    ctx.fill();
    ctx.restore();

    // Body
    ctx.fillStyle='#e8e8f0';
    ctx.beginPath();
    ctx.arc(gx, gy-4, 13, Math.PI, 0); // top dome
    ctx.lineTo(gx+13, gy+8);
    // wavy bottom
    for (let wx=gx+13; wx>=gx-13; wx-=4) {
      const wbobble = Math.sin((wx-gx)*0.5+g.phase*3)*3;
      ctx.lineTo(wx, gy+10+wbobble);
    }
    ctx.lineTo(gx-13, gy+8);
    ctx.closePath();
    ctx.fill();

    // Outline
    ctx.strokeStyle='rgba(100,100,140,0.5)';
    ctx.lineWidth=1;
    ctx.stroke();

    // Eyes
    ctx.fillStyle='#3a1a6e';
    ctx.fillRect(gx-5, gy-5, 3, 4);
    ctx.fillRect(gx+2, gy-5, 3, 4);

    // Eye glow
    ctx.fillStyle='rgba(100,40,200,0.4)';
    ctx.fillRect(gx-5, gy-5, 3, 4);
    ctx.fillRect(gx+2, gy-5, 3, 4);
  }
}

// ── Particles ─────────────────────────────────────────────────────────────
function renderParticles() {
  for (const p of particles) {
    const a = (p.life/p.maxLife);
    ctx.globalAlpha = a*0.85;
    ctx.fillStyle = p.color;
    ctx.fillRect(p.x - p.size*a*0.5, p.y - p.size*a*0.5, p.size*a, p.size*a);
  }
  ctx.globalAlpha=1;
}

// ── HUD ───────────────────────────────────────────────────────────────────
function renderHUD() {
  const BAR_H = 28;

  // Background bar
  ctx.fillStyle='rgba(14,14,26,0.9)';
  ctx.fillRect(0, 0, W, BAR_H);
  // Bottom border
  ctx.fillStyle='#2a2a4a';
  ctx.fillRect(0, BAR_H, W, 1);

  // ── Score (left, top row) ───────────────────────────────────────────
  ctx.fillStyle='#6a6a8a';
  ctx.font='7px "Press Start 2P", monospace';
  ctx.textAlign='left';
  ctx.textBaseline='top';
  ctx.fillText('SCORE', 12, 2);
  ctx.fillStyle='#f0c840';
  ctx.font='bold 10px "Press Start 2P", monospace';
  ctx.fillText(score.toString(), 12, 11);

  // ── Health bar (left, bottom row) ───────────────────────────────────
  const hp = player.health;                       // 0–100
  const hpPct = hp / 100;
  const barX = 100, barY = 4, barW = 80, barH = 20;

  // Flash the entire health section when at 15% or below
  const dangerFlash = hp <= 15 && (Math.sin(Date.now() * 0.018) > 0);

  // Heart icon (pixel-art style, drawn with fills)
  const hx = 88, hy = 10; // heart center
  ctx.save();
  ctx.globalAlpha = dangerFlash ? 0.5 : 1;
  ctx.fillStyle = dangerFlash ? '#ff2222' : (hp <= 15 ? '#ff3333' : hp <= 40 ? '#ff8844' : '#e84a4a');
  // Two bumps
  ctx.beginPath();
  ctx.arc(hx - 3, hy - 2, 3.5, Math.PI, 0);
  ctx.arc(hx + 3, hy - 2, 3.5, Math.PI, 0);
  // Bottom point
  ctx.lineTo(hx, hy + 5);
  ctx.closePath();
  ctx.fill();
  // Heart highlight
  ctx.fillStyle = 'rgba(255,255,255,0.3)';
  ctx.fillRect(hx - 4, hy - 4, 3, 2);
  ctx.restore();

  // Label "HEALTH"
  ctx.save();
  ctx.globalAlpha = dangerFlash ? 0.5 : 1;
  ctx.fillStyle='#6a6a8a';
  ctx.font='6px "Press Start 2P", monospace';
  ctx.textAlign='left';
  ctx.textBaseline='top';
  ctx.fillText('HEALTH', barX, 2);
  ctx.restore();

  // Bar track (background)
  ctx.fillStyle = 'rgba(40,40,55,0.9)';
  ctx.fillRect(barX, 10, barW, 10);
  ctx.strokeStyle = '#2a2a4a';
  ctx.lineWidth = 1;
  ctx.strokeRect(barX + 0.5, 10.5, barW - 1, 9);

  // Bar fill — color shifts with health
  const fillW = Math.max(0, barW * hpPct);
  ctx.save();
  ctx.globalAlpha = dangerFlash ? 0.55 : 1;
  if (hp <= 15)      ctx.fillStyle = '#ff2222';
  else if (hp <= 40) ctx.fillStyle = '#ff7722';
  else if (hp <= 70) ctx.fillStyle = '#eecc22';
  else               ctx.fillStyle = '#44dd66';
  ctx.fillRect(barX + 1, 11, fillW - 2, 8);

  // Subtle segment lines inside the bar
  ctx.fillStyle = 'rgba(0,0,0,0.18)';
  for (let seg = 1; seg < 5; seg++) {
    const sx = barX + (barW / 5) * seg;
    if (sx < barX + fillW) ctx.fillRect(sx, 11, 1, 8);
  }
  ctx.restore();

  // Percentage label (right-aligned inside bar)
  ctx.save();
  ctx.globalAlpha = dangerFlash ? 0.5 : 1;
  ctx.fillStyle = hp <= 15 ? '#ffffff' : '#c0c0c0';
  ctx.font = 'bold 7px "Press Start 2P", monospace';
  ctx.textAlign = 'right';
  ctx.textBaseline = 'middle';
  ctx.fillText(hp + '%', barX + barW - 3, 15);
  ctx.restore();

  // ── Carry slots (center) ────────────────────────────────────────────
  const slotW = 14, slotH = 11, gap = 3;
  const totalW = CARRY_LIMIT*(slotW+gap)-gap;
  const startX = W/2 - totalW/2;

  for (let i=0; i<CARRY_LIMIT; i++) {
    const sx = startX + i*(slotW+gap);
    const sy = (BAR_H - slotH) / 2;
    if (i < player.carrying.length) {
      const b = player.carrying[i];
      ctx.fillStyle = BOOK_COLORS[b.type];
      ctx.fillRect(sx, sy, slotW, slotH);
      ctx.strokeStyle='rgba(0,0,0,0.5)';
      ctx.lineWidth=1;
      ctx.strokeRect(sx+0.5, sy+0.5, slotW-1, slotH-1);
    } else {
      ctx.strokeStyle='#3a3a5a';
      ctx.lineWidth=1;
      ctx.strokeRect(sx+0.5, (BAR_H - slotH)/2 + 0.5, slotW-1, slotH-1);
    }
  }

  // ── Timer (right) ───────────────────────────────────────────────────
  const secs = Math.ceil(timeLeft);
  ctx.fillStyle='#6a6a8a';
  ctx.font='7px "Press Start 2P", monospace';
  ctx.textAlign='right';
  ctx.textBaseline='top';
  ctx.fillText('TIME', W-12, 2);
  ctx.fillStyle = secs<=15 ? '#ff2020' : secs<=30 ? '#ff8040' : '#e04040';
  ctx.font='bold 11px "Press Start 2P", monospace';
  ctx.textBaseline='top';
  ctx.fillText(secs.toString(), W-12, 12);

  // ── Combo (floats just below the bar) ───────────────────────────────
  if (combo>=2) {
    const colors = ['#f0c840','#ff8840','#ff4040','#ff40ff','#40ffff'];
    const ci = Math.min(combo-2, colors.length-1);
    ctx.fillStyle = colors[ci];
    ctx.font='bold 9px "Press Start 2P", monospace';
    ctx.textAlign='center';
    ctx.textBaseline='top';
    ctx.fillText(combo+'x COMBO', W/2, BAR_H + 3);
  }
}

// ── Feedbacks ─────────────────────────────────────────────────────────────
function renderFeedbacks() {
  ctx.textAlign='center';
  ctx.textBaseline='middle';
  for (const f of feedbacks) {
    const a = Math.min(1, f.life/400);
    ctx.globalAlpha=a;
    ctx.fillStyle=f.color;
    ctx.font='bold 13px "Press Start 2P", monospace';
    ctx.fillText(f.txt, f.x, f.y);
  }
  ctx.globalAlpha=1;
}

// ── Flash overlay (ghost hit) ─────────────────────────────────────────────
function renderFlash() {
  if (flashAlpha>0) {
    ctx.fillStyle=`rgba(255,30,30,${flashAlpha})`;
    ctx.fillRect(0,0,W,H);
  }
}

// ── Pause overlay ─────────────────────────────────────────────────────────
function renderPauseOverlay() {
  // Dark scrim over the live game world
  ctx.fillStyle = 'rgba(10, 10, 22, 0.72)';
  ctx.fillRect(0, 0, W, H);

  // Panel
  const pw = 240, ph = 160;
  const px = W/2 - pw/2, py = H/2 - ph/2;

  // Panel shadow
  ctx.fillStyle = 'rgba(0,0,0,0.4)';
  roundRect(ctx, px+4, py+4, pw, ph, 8);
  ctx.fill();

  // Panel body
  ctx.fillStyle = 'rgba(18, 18, 34, 0.95)';
  roundRect(ctx, px, py, pw, ph, 8);
  ctx.fill();

  // Panel border
  ctx.strokeStyle = '#3a3a5e';
  ctx.lineWidth = 2;
  roundRect(ctx, px, py, pw, ph, 8);
  ctx.stroke();

  // Top accent line
  ctx.fillStyle = '#c8a84a';
  ctx.fillRect(px + 20, py + 28, pw - 40, 1);

  // "PAUSED" title
  ctx.fillStyle = '#c8a84a';
  ctx.font = 'bold 18px "Press Start 2P", monospace';
  ctx.textAlign = 'center';
  ctx.textBaseline = 'middle';
  ctx.fillText('PAUSED', W/2, py + 18);

  // Current score
  ctx.fillStyle = '#6a6a8a';
  ctx.font = '7px "Press Start 2P", monospace';
  ctx.fillText('SCORE', W/2, py + 48);
  ctx.fillStyle = '#f0c840';
  ctx.font = 'bold 13px "Press Start 2P", monospace';
  ctx.fillText(score.toString(), W/2, py + 65);

  // Bottom accent line
  ctx.fillStyle = '#3a3a5e';
  ctx.fillRect(px + 30, py + 82, pw - 60, 1);

  // Blinking prompts
  const blink = Math.sin(Date.now() * 0.006) > 0;

  // Resume prompt
  ctx.fillStyle = blink ? '#e8e8e8' : 'rgba(180,180,180,0.35)';
  ctx.font = 'bold 9px "Press Start 2P", monospace';
  ctx.fillText('ESC — Resume', W/2, py + 105);

  // Quit prompt
  ctx.fillStyle = blink ? '#d06040' : 'rgba(180,180,180,0.35)';
  ctx.font = 'bold 9px "Press Start 2P", monospace';
  ctx.fillText('ENTER — Quit to Title', W/2, py + 130);
}

// ── Title Screen ──────────────────────────────────────────────────────────
function renderTitle() {
  ctx.fillStyle='#0e0e1a';
  ctx.fillRect(0,0,W,H);
  // gradient
  const grd = ctx.createLinearGradient(0,0,0,H);
  grd.addColorStop(0,'rgba(14,14,26,1)');
  grd.addColorStop(1,'rgba(26,26,46,1)');
  ctx.fillStyle=grd;
  ctx.fillRect(0,0,W,H);

  // Top shelf silhouette
  ctx.fillStyle='#151525';
  ctx.fillRect(0,0,W,42);
  ctx.fillStyle='#2a2a3e';
  ctx.fillRect(0,40,W,2);
  // Book silhouettes
  const bc=[0xe84a8a,0x2ea05c,0x7a2ec0,0x2e5cc0,0x00bfff,0x222222,0xd4a82e,0xe87a2e,0x8a8a9a];
  for (let i=0;i<16;i++) {
    const bx=28+i*46+(i%3)*3, bw=9+(i%3)*4, bh=18+(i%4)*3;
    ctx.fillStyle='#'+bc[i%5].toString(16).padStart(6,'0');
    ctx.fillRect(bx, 42-bh, bw, bh);
  }

  // Title
  ctx.fillStyle='#c8a84a';
  ctx.font='bold 36px "Press Start 2P", monospace';
  ctx.textAlign='center'; ctx.textBaseline='middle';
  ctx.strokeStyle='#0e0e1a';
  ctx.lineWidth=5;
  ctx.strokeText('THE LUCHABRARIAN', W/2, 110);
  ctx.fillText('THE LUCHABRARIAN', W/2, 110);

  ctx.fillStyle='#8a7a4a';
  ctx.font='12px "Press Start 2P", monospace';
  ctx.fillText('A Luchador Librarian Story', W/2, 155);

  // Divider
  ctx.fillStyle='rgba(200,168,74,0.35)';
  ctx.fillRect(W/2-70,172,140,2);

  // Luchador hero pose (drawn procedurally, larger)
  renderTitleLuchador(W/2, 230);

  // Story
  ctx.fillStyle='#a0a0b8';
  ctx.font='8px "Press Start 2P", monospace';
  ctx.textAlign='center';
  const lines=['The books have been returned','in the WRONG ORDER.','','Only one luchador librarian','— The Luchabrarian —','can restore the chaos.','','Some books belong on shelves.','Some belong in the trash.','The library closes at midnight.'];
  lines.forEach((l,i) => ctx.fillText(l, W/2, 305+i*13));

  // Press to start (blinking)
  const blink = Math.sin(Date.now()*0.005)>0;
  if (blink) {
    ctx.fillStyle='#c8a84a';
    ctx.font='bold 10px "Press Start 2P", monospace';
    ctx.fillText('PRESS SPACE TO START', W/2, H-40);
  }
}

function renderTitleLuchador(cx, cy) {
  ctx.save();
  ctx.translate(cx, cy);
  const s = 2.8;
  ctx.scale(s, s);

  // Shadow
  ctx.fillStyle='rgba(0,0,0,0.2)';
  ctx.beginPath(); ctx.ellipse(0,18,16,5,0,0,Math.PI*2); ctx.fill();

  // Legs
  ctx.fillStyle='#2c2c6e';
  ctx.fillRect(-5,8,4,8);
  ctx.fillRect(1,8,4,8);
  // Boots
  ctx.fillStyle='#3d2b1a';
  ctx.fillRect(-5,16,4,3);
  ctx.fillRect(1,16,4,3);
  // Body
  ctx.fillStyle='#b81c1c';
  ctx.fillRect(-7,-2,14,10);
  ctx.fillStyle='#1e7a1e';
  ctx.fillRect(-5,0,10,5);
  // Arms (heroic pose — slightly raised)
  ctx.fillStyle='#e8b88a';
  ctx.fillRect(-10,-3,3,7);
  ctx.fillRect(7,-3,3,7);
  ctx.fillStyle='#b81c1c';
  ctx.fillRect(-10,-3,3,3);
  ctx.fillRect(7,-3,3,3);
  // Head
  ctx.fillStyle='#e8b88a';
  ctx.fillRect(-6,-12,12,8);
  // Mask
  ctx.fillStyle='#d62a2a';
  ctx.fillRect(-6,-12,12,6);
  ctx.fillStyle='#fff';
  ctx.fillRect(-6,-12,12,2);
  ctx.fillStyle='#2a8c2a';
  ctx.fillRect(-6,-10,12,1);
  // Eyes
  ctx.fillStyle='#1a1a1a';
  ctx.fillRect(-4,-8,3,2);
  ctx.fillRect(1,-8,3,2);
  // Outline
  ctx.strokeStyle='#1a1a1a'; ctx.lineWidth=0.7;
  ctx.strokeRect(-6.5,-12.5,13,9);
  ctx.strokeRect(-7.5,-2.5,15,11);

  ctx.restore();
}

// ── Game Over ─────────────────────────────────────────────────────────────
function renderGameOver() {
  ctx.fillStyle='#0a0a14';
  ctx.fillRect(0,0,W,H);
  const grd=ctx.createLinearGradient(0,0,0,H);
  grd.addColorStop(0,'rgba(10,10,20,1)');
  grd.addColorStop(1,'rgba(20,20,40,1)');
  ctx.fillStyle=grd;
  ctx.fillRect(0,0,W,H);

  const won = player._won;

  // Header
  ctx.textAlign='center'; ctx.textBaseline='middle';
  ctx.strokeStyle='#0a0a14'; ctx.lineWidth=5;
  ctx.font='bold 24px "Press Start 2P", monospace';
  const title = won ? '★ ORDER RESTORED ★' : '★ LIBRARY CLOSED ★';
  ctx.strokeText(title, W/2, 80);
  ctx.fillStyle = won?'#f0c840':'#d62a2a';
  ctx.fillText(title, W/2, 80);

  ctx.font='9px "Press Start 2P", monospace';
  if (won) {
    ctx.fillStyle='#a0a0b8';
    ctx.fillText('The library is saved.', W/2, 118);
  } else if (player._cause === 'health') {
    ctx.fillStyle='#ff4444';
    ctx.fillText('The ghosts defeated you.', W/2, 118);
  } else {
    ctx.fillStyle='#a0a0b8';
    ctx.fillText(player._booksLeft+' book'+(player._booksLeft!==1?'s':'')+' left unfiled.', W/2, 118);
  }

  // Luchador
  renderTitleLuchador(W/2, 210);

  // Score
  ctx.fillStyle='#6a6a8a';
  ctx.font='8px "Press Start 2P", monospace';
  ctx.fillText('FINAL SCORE', W/2, 290);
  ctx.fillStyle='#f0c840';
  ctx.font='bold 32px "Press Start 2P", monospace';
  ctx.fillText(player._score.toString(), W/2, 330);

  // Divider
  ctx.fillStyle = won?'rgba(240,200,64,0.3)':'rgba(214,42,42,0.3)';
  ctx.fillRect(W/2-50,355,100,2);

  // Play again button
  ctx.fillStyle='rgba(26,26,46,0.9)';
  roundRect(ctx, W/2-75, 370, 150, 38, 6);
  ctx.fill();
  ctx.strokeStyle = won?'#f0c840':'#d62a2a';
  ctx.lineWidth=2;
  roundRect(ctx, W/2-75, 370, 150, 38, 6);
  ctx.stroke();

  const blink=Math.sin(Date.now()*0.007)>0;
  ctx.fillStyle = blink?(won?'#f0c840':'#d62a2a'):'rgba(200,200,200,0.3)';
  ctx.font='bold 11px "Press Start 2P", monospace';
  ctx.fillText('PLAY AGAIN', W/2, 389);

  ctx.fillStyle='#4a4a6a';
  ctx.font='7px "Press Start 2P", monospace';
  ctx.fillText('SPACE or CLICK  |  ESC for title', W/2, H-22);
}

// ── Util: rounded rect path ───────────────────────────────────────────────
function roundRect(c,x,y,w,h,r) {
  c.beginPath();
  c.moveTo(x+r,y);
  c.lineTo(x+w-r,y);
  c.quadraticCurveTo(x+w,y,x+w,y+r);
  c.lineTo(x+w,y+h-r);
  c.quadraticCurveTo(x+w,y+h,x+w-r,y+h);
  c.lineTo(x+r,y+h);
  c.quadraticCurveTo(x,y+h,x,y+h-r);
  c.lineTo(x,y+r);
  c.quadraticCurveTo(x,y,x+r,y);
  c.closePath();
}

// ═══════════════════════════════════════════════════════════════════════════
// LOOP
// ═══════════════════════════════════════════════════════════════════════════
function loop(time) {
  const dt = lastTime ? Math.min(time-lastTime, 100) : 16; // cap at 100ms
  lastTime = time;

  // Consume input edges AFTER update reads them
  update(dt);
  render();

  // Clear edges after frame
  for (const k in keyDown) keyDown[k]=false;
  for (const k in keyUp) keyUp[k]=false;

  requestAnimationFrame(loop);
}
requestAnimationFrame(loop);

// Click-to-start on gameover
canvas.addEventListener('click', ()=>{
  if (state==='title') initGame();
  else if (state==='gameover') initGame();
});
</script>
</body>
</html>
